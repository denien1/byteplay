<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>BytePlay — Play</title>
  <link rel="stylesheet" href="styles.css"/>
</head>
<body>
  <div class="player">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
      <a class="btn" href="./">← Back</a>
      <span id="title" class="meta"></span>
      <div>
        <button class="btn" id="fullscreen">Fullscreen</button>
        <button class="btn" id="restart">Restart</button>
      </div>
    </div>
    <div id="msg" class="err"></div>
    <div class="canvas"><div id="game"></div></div>
  </div>

  <script>
    const params = new URL(location.href).searchParams;
    const id = params.get('id') || '';

    async function boot() {
      let meta = null;
      try {
        const res = await fetch('games.json', { cache: 'no-store' });
        const data = await res.json();
        meta = (data.games || []).find(g => g.id === id);
      } catch (e) {
        document.getElementById('msg').textContent = 'Failed to load games.json';
        console.error(e);
        return;
      }

      // BYOR — Bring Your Own ROM
      if (!meta && id === 'byor') {
        document.getElementById('title').textContent = 'Bring Your Own ROM';
        document.getElementById('msg').textContent = 'Choose a ROM file (.gba, .gbc, .gb, .sfc/.smc, .zip, .a26).';
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.gba,.gbc,.gb,.sfc,.smc,.nes,.zip,.a26';
        input.className = 'btn';
        input.style.margin = '10px 0';
        input.onchange = () => {
          const f = input.files?.[0];
          if (!f) return;
          // REQUIRED: set EJS_* BEFORE loading loader.js
          window.EJS_player     = '#game';
          window.EJS_core       = guessCore(f.name);
          window.EJS_gameUrl    = URL.createObjectURL(f);
          window.EJS_pathtodata = 'data/';
          console.log('EJS_core:', window.EJS_core);
          const s = document.createElement('script');
          s.src = 'data/loader.js';
          document.body.appendChild(s);
        };
        document.querySelector('.player').insertBefore(input, document.querySelector('.canvas'));
        wireToolbar();
        return;
      }

      if (!meta) {
        document.getElementById('msg').textContent = 'Game not found.';
        wireToolbar();
        return;
      }

      document.getElementById('title').textContent = meta.title || '';

      // REQUIRED: set EJS_* BEFORE loading loader.js
      window.EJS_player     = '#game';
      window.EJS_core       = meta.core;           // "gba" | "snes" | "fbneo" | "atari2600"
      window.EJS_gameUrl    = meta.rom;            // e.g., roms/neogeo/kof98.zip
      window.EJS_pathtodata = 'data/';             // contains loader.js and cores
      if (meta.bios) window.EJS_biosUrl = meta.bios; // e.g., roms/neogeo/neogeo.zip

      // Helpful debug logs (open DevTools Console to see)
      console.log('EJS_core:', window.EJS_core);
      console.log('EJS_gameUrl:', window.EJS_gameUrl);
      console.log('EJS_biosUrl:', window.EJS_biosUrl);
      console.log('EJS_pathtodata:', window.EJS_pathtodata);

      // Load the EmulatorJS loader AFTER the variables are set
      const s = document.createElement('script');
      s.src = 'data/loader.js';
      s.onerror = () => {
        document.getElementById('msg').textContent = 'Could not load data/loader.js — ensure the local data/ folder exists.';
      };
      document.body.appendChild(s);

      wireToolbar();
    }

    function wireToolbar() {
      document.getElementById('fullscreen').onclick = () => {
        const el = document.querySelector('.canvas');
        (el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen || (() => {})).call(el);
      };
      document.getElementById('restart').onclick = () => location.reload();
    }

    function guessCore(n) {
      n = n.toLowerCase();
      if (n.endsWith('.gba')) return 'gba';
      if (n.endsWith('.gbc')) return 'gbc';
      if (n.endsWith('.gb'))  return 'gb';
      if (n.endsWith('.sfc') || n.endsWith('.smc')) return 'snes';
      if (n.endsWith('.nes')) return 'nes';
      if (n.endsWith('.a26')) return 'atari2600';
      if (n.endsWith('.zip')) return 'fbneo'; // most arcade/Neo-Geo sets
      return 'gba';
    }

    boot();
  </script>
</body>
</html>

<!-- Morphing mesh background -->
<!-- Morphing mesh background -->
<canvas id="bg-mesh" aria-hidden="true"></canvas>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.155.0/build/three.module.js";

  const CONFIG = {
    density: 120,
    amplitude: 0.9,
    speed: 0.25,
    scale: 1.2,
    colors: {
      top:   new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--mesh-top').trim() || "#0b1f3a"),
      mid:   new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--mesh-mid').trim() || "#10273f"),
      bot:   new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--mesh-bot').trim() || "#08111e"),
      glowA: new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--mesh-glowA').trim() || "#7c4dff"),
      glowB: new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--mesh-glowB').trim() || "#00b7ff"),
    }
  };
  const reduceMotion = matchMedia("(prefers-reduced-motion: reduce)").matches;

  const canvas = document.getElementById("bg-mesh");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  renderer.setClearColor(0x000000, 0);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 100);
  camera.position.set(0, 0.4, 2.2);

  const segments = CONFIG.density;
  const geometry = new THREE.PlaneGeometry(4, 2.6, segments, segments);
  geometry.rotateX(-Math.PI/2);
  geometry.rotateZ(Math.PI*0.02);

  const vertexShader = `
    vec3 mod289(vec3 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
    vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
    vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}
    vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
    float snoise(vec3 v){
      const vec2  C = vec2(1.0/6.0, 1.0/3.0);
      const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
      vec3 i  = floor(v + dot(v, C.yyy));
      vec3 x0 = v - i + dot(i, C.xxx);
      vec3 g = step(x0.yzx, x0.xyz);
      vec3 l = 1.0 - g;
      vec3 i1 = min(g.xyz, l.zxy);
      vec3 i2 = max(g.xyz, l.zxy);
      vec3 x1 = x0 - i1 + 1.0*C.xxx;
      vec3 x2 = x0 - i2 + 2.0*C.xxx;
      vec3 x3 = x0 - 1.0 + 3.0*C.xxx;
      i = mod289(i);
      vec4 p = permute(permute(permute(
                 i.z + vec4(0.0, i1.z, i2.z, 1.0))
               + i.y + vec4(0.0, i1.y, i2.y, 1.0))
               + i.x + vec4(0.0, i1.x, i2.x, 1.0));
      float n_ = 0.142857142857;
      vec3  ns = n_ * D.wyz - D.xzx;
      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
      vec4 x_ = floor(j * ns.z);
      vec4 y_ = floor(j - 7.0 * x_);
      vec4 x = x_ * ns.x + ns.yyyy;
      vec4 y = y_ * ns.x + ns.yyyy;
      vec4 h = 1.0 - abs(x) - abs(y);
      vec4 b0 = vec4(x.xy, y.xy);
      vec4 b1 = vec4(x.zw, y.zw);
      vec4 s0 = floor(b0)*2.0 + 1.0;
      vec4 s1 = floor(b1)*2.0 + 1.0;
      vec4 sh = -step(h, vec4(0.0));
      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
      vec3 p0 = vec3(a0.xy,h.x);
      vec3 p1 = vec3(a1.xy,h.y);
      vec3 p2 = vec3(a0.zw,h.z);
      vec3 p3 = vec3(a1.zw,h.w);
      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
      p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
      vec4 m = max(0.6 - vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)), 0.0);
      m = m*m;
      return 42.0 * dot(m*m, vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
    }
    uniform float uTime, uAmp, uScale, uSpeed;
    varying float vH; varying vec2 vUv;
    void main(){
      vUv = uv;
      vec2 p = (uv - 0.5) * vec2(3.5, 2.0);
      float t = uTime * uSpeed;
      float n = snoise(vec3(p * uScale, t));
      float h = n * uAmp;
      vH = h;
      vec3 pos = position;
      pos.y += h;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.0);
    }
  `;
  const fragmentShader = `
    precision highp float;
    varying float vH; varying vec2 vUv;
    uniform vec3 uTop,uMid,uBot,uGlowA,uGlowB;
    void main(){
      vec3 base = mix(uTop, uBot, vUv.y);
      base = mix(base, uMid, 0.25 + 0.25*sin(vUv.y*3.1415));
      float g1 = smoothstep(0.05, 0.35, vH);
      float g2 = smoothstep(0.0,  0.25, -vH);
      vec3 color = base + g1*uGlowA*0.25 + g2*uGlowB*0.20;
      vec2 c = vUv - 0.5;
      float vig = smoothstep(0.95, 0.15, dot(c,c));
      color *= mix(0.95, 1.0, vig);
      gl_FragColor = vec4(color, 0.95);
    }
  `;
  const uniforms = {
    uTime:{value:0}, uAmp:{value:CONFIG.amplitude}, uScale:{value:CONFIG.scale},
    uSpeed:{value: reduceMotion ? 0.02 : CONFIG.speed},
    uTop:{value:CONFIG.colors.top}, uMid:{value:CONFIG.colors.mid},
    uBot:{value:CONFIG.colors.bot}, uGlowA:{value:CONFIG.colors.glowA}, uGlowB:{value:CONFIG.colors.glowB},
  };
  const material = new THREE.ShaderMaterial({ vertexShader, fragmentShader, uniforms, transparent:true });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.y = -0.6;
  scene.add(mesh);

  let stop=false;
  function tick(t){ if(stop) return; uniforms.uTime.value=t*0.001; renderer.render(scene,camera); requestAnimationFrame(tick); }
  requestAnimationFrame(tick);

  addEventListener("resize", ()=>{
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(innerWidth, innerHeight);
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  });
  document.addEventListener("visibilitychange", ()=>{ stop=document.hidden; if(!stop) requestAnimationFrame(tick); });
</script>
